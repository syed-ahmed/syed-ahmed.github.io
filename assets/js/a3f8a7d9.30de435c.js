"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[541],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(n),d=i,k=c["".concat(p,".").concat(d)]||c[d]||u[d]||r;return n?a.createElement(k,l(l({ref:t},m),{},{components:n})):a.createElement(k,l({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5071:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return u}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={},p="C++ Crash Course",s={unversionedId:"cpp/crash_course",id:"cpp/crash_course",title:"C++ Crash Course",description:"Importing",source:"@site/docs/cpp/0_crash_course.md",sourceDirName:"cpp",slug:"/cpp/crash_course",permalink:"/docs/cpp/crash_course",editUrl:"https://github.com/syed-ahmed/syed-ahmed.github.io/blob/main/website/docs/cpp/0_crash_course.md?plain=1",tags:[],version:"current",sidebarPosition:0,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Notes",permalink:"/docs/intro"},next:{title:"Introduction to CUDA C++",permalink:"/docs/cuda/intro"}},m={},u=[{value:"Importing",id:"importing",level:2},{value:"Preprocessor Directives",id:"preprocessor-directives",level:2},{value:"Main function",id:"main-function",level:2},{value:"I/O Streams",id:"io-streams",level:2},{value:"Namespaces",id:"namespaces",level:2},{value:"Literals",id:"literals",level:2},{value:"Variables",id:"variables",level:2}],c={toc:u};function d(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"c-crash-course"},"C++ Crash Course"),(0,r.kt)("h2",{id:"importing"},"Importing"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#include")," replaced by ",(0,r.kt)("inlineCode",{parentName:"li"},"import")," in C++20. New concept called modules.\ne.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"import <iostream>")," instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"#include <iostream>"),".")),(0,r.kt)("h2",{id:"preprocessor-directives"},"Preprocessor Directives"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Directives starting with ",(0,r.kt)("inlineCode",{parentName:"li"},"#")," uses the preprocessor."),(0,r.kt)("li",{parentName:"ul"},"Function declaration: signature  for the function, inputs, output, types."),(0,r.kt)("li",{parentName:"ul"},"Function definition: actual code of the function."),(0,r.kt)("li",{parentName:"ul"},"With C++20 modules, no need to separate declaration from definition.\nCan do it if wanted to."),(0,r.kt)("li",{parentName:"ul"},"Old C standard library do not use namespace. Standard C library\nprefixed with ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," use the ",(0,r.kt)("inlineCode",{parentName:"li"},"std")," namespace. C standard library\nare not guaranteed to be importable with ",(0,r.kt)("inlineCode",{parentName:"li"},"import")," in C++20."),(0,r.kt)("li",{parentName:"ul"},"Common preprocessor directive:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#include"),": header files."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#define"),": macro."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#ifdef...#endif"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"#ifndef...#endif"),": prevents circular includes\nExample:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#ifndef TEST_FILE_H\n#define TEST_FILE_H\n// ...\n#endif\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"#pragma"),": compiler specific directive. Can replace the above with\n",(0,r.kt)("inlineCode",{parentName:"li"},"#pragma once"),".")))),(0,r.kt)("h2",{id:"main-function"},"Main function"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"main()"),": start of the program. ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Return type is ",(0,r.kt)("inlineCode",{parentName:"li"},"int"),"."),(0,r.kt)("li",{parentName:"ul"},"zero returned automatically if not explicit."),(0,r.kt)("li",{parentName:"ul"},"can take no params or two params: ",(0,r.kt)("inlineCode",{parentName:"li"},"int argc, char* argv[]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"argc"),": number of args passed to program."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"argv"),": actual args starting at index 1. Index 0 can be the program\nname.")))),(0,r.kt)("h2",{id:"io-streams"},"I/O Streams"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::cout"),": outputs to user console."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::cerr"),": outputs to error console."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<<"),": outputs down the stream."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::endl"),": end of line sequence. Output everything and move to next\nline. Alternatively use ",(0,r.kt)("inlineCode",{parentName:"li"},"\\n")," escape sequence, i.e. a new line char."),(0,r.kt)("li",{parentName:"ul"},"Use ",(0,r.kt)("inlineCode",{parentName:"li"},"std::format")," with C++20, from ",(0,r.kt)("inlineCode",{parentName:"li"},"<format>"),"."),(0,r.kt)("li",{parentName:"ul"},"Common escape sequences to be used with quotes:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\\n"),": new line, moves cursor to beginning of next line and advance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\\r"),": carriage return, moves cursor to beginning of next line\nbut doesn't advance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\\t"),": tab."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\\\\"),": backslash."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'\\"'),": quotation."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::endl")," flushes the buffer, so it will have a performance impact.\n",(0,r.kt)("inlineCode",{parentName:"li"},"\\n")," doesn't flush the buffer."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::cin"),": accept input from user with the ",(0,r.kt)("inlineCode",{parentName:"li"},">>")," operator."),(0,r.kt)("li",{parentName:"ul"},"Use iostream and format instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"printf")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"scanf"),", since they\nprovide type safety.")),(0,r.kt)("h2",{id:"namespaces"},"Namespaces"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"namespace")," avoids naming conflict, defines a context for the names.\nExample:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'namespace my_lib {\n  void foo() {\n    std::cout << "Hi!" << std::endl;\n  }\n}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Call using scope resolution operator",(0,r.kt)("inlineCode",{parentName:"p"},"::"),". Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"my_lib::foo();"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Code in the same namespace can call each other without usiing scope\nresolution. Makes code readable.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"using")," directive: signals the compiler that subsequent code is from\nthe specified namespace.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Don't overuse ",(0,r.kt)("inlineCode",{parentName:"p"},"using"),", will create name conflicts.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Can use ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," for a particular item. Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"using std::cout"),"\nand then just referring ",(0,r.kt)("inlineCode",{parentName:"p"},"cout"),". That way everything else still\nneeds to use ",(0,r.kt)("inlineCode",{parentName:"p"},"std::"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Never put ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," in a header file or global scope. Use it in\nnamespace or class scope. OK to use ",(0,r.kt)("inlineCode",{parentName:"p"},"using")," in a module interface\nfile as long as not exporting.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Nested namespace: namespace inside another one.\nExample:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// before c++17\nnamespace foo {\n  namespace bar {\n\n  }\n}\n// after c++17\nnamespace foo::bar {\n\n}\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Namespace alias: give new/shorter name to a namespace.\nExample: `namespace baz = foo::bar;"))),(0,r.kt)("h2",{id:"literals"},"Literals"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Literals: used to write numbers or strings.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"decimal, 123"),(0,r.kt)("li",{parentName:"ul"},"octal, 0173"),(0,r.kt)("li",{parentName:"ul"},"hex, 0x7B"),(0,r.kt)("li",{parentName:"ul"},"binary, 0b1111011"),(0,r.kt)("li",{parentName:"ul"},"float, 3.14f"),(0,r.kt)("li",{parentName:"ul"},"double, 3.14"),(0,r.kt)("li",{parentName:"ul"},"hex float, 0x3.ABCp-10"),(0,r.kt)("li",{parentName:"ul"},"single char, 'a'"),(0,r.kt)("li",{parentName:"ul"},"zero terminated char array"))),(0,r.kt)("li",{parentName:"ul"},"Can define custom literal."),(0,r.kt)("li",{parentName:"ul"},"Digit separator can be used in numeric literals, i.e. single\nquote char. Example: 23'456'789.")),(0,r.kt)("h2",{id:"variables"},"Variables"))}d.isMDXComponent=!0}}]);