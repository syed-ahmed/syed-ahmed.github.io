"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1415],{6976:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var t=s(4848),a=s(8453);const i={},l="Anatomy of a Static Analysis",o={id:"LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis/static_analysis_anatomy",title:"Anatomy of a Static Analysis",description:"Example Static Analysis Problem",source:"@site/docs/LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis/5_static_analysis_anatomy.md",sourceDirName:"LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis",slug:"/LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis/static_analysis_anatomy",permalink:"/docs/LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis/static_analysis_anatomy",draft:!1,unlisted:!1,editUrl:"https://github.com/syed-ahmed/syed-ahmed.github.io/blob/main/website/docs/LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis/5_static_analysis_anatomy.md?plain=1",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Discovering Invariants by Dynamic and Static Analysis",permalink:"/docs/LLVM/CIS 547 Software Analysis/Module 1: Introduction to Software Analysis/discover_invariants"},next:{title:"Installing LLVM",permalink:"/docs/LLVM/llvm_techniques/Section 1/install"}},r={},c=[{value:"Example Static Analysis Problem",id:"example-static-analysis-problem",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Control-flow graph",id:"control-flow-graph",level:3},{value:"Abstract vs. concrete states",id:"abstract-vs-concrete-states",level:3},{value:"Termination",id:"termination",level:3},{value:"Completeness",id:"completeness",level:3},{value:"Soundness",id:"soundness",level:3},{value:"Example Abstract Domain",id:"example-abstract-domain",level:2},{value:"Recap: Parts of a Static Analysis",id:"recap-parts-of-a-static-analysis",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"anatomy-of-a-static-analysis",children:"Anatomy of a Static Analysis"}),"\n",(0,t.jsx)(n.h2,{id:"example-static-analysis-problem",children:"Example Static Analysis Problem"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Problem: find variables that have a constant value at a given program point."}),"\n",(0,t.jsxs)(n.li,{children:["Example code:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"void main() {\n    z = 3;\n    while (true) {\n        if(x == 1)\n            y = 7;\n        else\n            y = z + 4;\n        assert(y == 7);\n    }\n}\n"})}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Formulate question as static analysis problem."}),"\n",(0,t.jsx)(n.li,{children:"Static analysis can discover y = 7, at the end of each iteration of the loop."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsx)(n.h3,{id:"control-flow-graph",children:"Control-flow graph"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Static analysis operates on a intermediate representation."}),"\n",(0,t.jsxs)(n.li,{children:["CFG is a representation of the program.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A DAG summarizes the flow of control in all possible runs of the program."}),"\n",(0,t.jsx)(n.li,{children:"Each node refers to a unique statement in the program."}),"\n",(0,t.jsx)(n.li,{children:"Each edge from a node is a successor of that node."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"abstract-vs-concrete-states",children:"Abstract vs. concrete states"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Abstract state: static analysis tracking the variables at each program point."}),"\n",(0,t.jsx)(n.li,{children:"Concrete state: actual values of the variables in a run."}),"\n",(0,t.jsx)(n.li,{children:"Static analysis does not run the program -> so does not operate over concrete states. Operates over abstract states."}),"\n",(0,t.jsx)(n.li,{children:"Abstract state -> set of concrete states -> known as abstract semantics -> vs concrete semantics."}),"\n",(0,t.jsxs)(n.li,{children:["Static analysis may fail to find variable value in abstract state -> represent it by ",(0,t.jsx)(n.code,{children:"?"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"termination",children:"Termination"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Abstract semantics ensures termination of static analysis."}),"\n",(0,t.jsx)(n.li,{children:"Can miss value of variable that are constant."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"completeness",children:"Completeness"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Static analysis sacrifices completeness because it can miss values."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"soundness",children:"Soundness"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When analysis concludes the value of a variable, this is\ncorrect for all runs -> therefore static analysis is sound."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-abstract-domain",children:"Example Abstract Domain"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Designing static analysis is an art."}),"\n",(0,t.jsx)(n.li,{children:"No best choice of abstract semantics. Concrete semantics dictated by program."}),"\n",(0,t.jsx)(n.li,{children:"Different abstract semantic choice lead different results."}),"\n",(0,t.jsx)(n.li,{children:"Right choice depends on the consumer of the analysis."}),"\n",(0,t.jsxs)(n.li,{children:["Designing an abstract semantic","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Step 1: Design an abstract domain.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["shows possible abstract values each ",(0,t.jsx)(n.code,{children:"int"})," variable can take."]}),"\n",(0,t.jsx)(n.li,{children:"also include two special values."}),"\n",(0,t.jsx)(n.li,{children:"top -> ? -> unknown to the analysis."}),"\n",(0,t.jsx)(n.li,{children:"bottom -> _|_ -> underfined to the analysis."}),"\n",(0,t.jsx)(n.li,{children:"arranged in a lattice structure -> showing possible order in which how values might changed as it goes through the analysis."}),"\n",(0,t.jsxs)(n.li,{children:["Example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Iterative Approximation:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Initial state:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"abstract value top at the entry of the progam."}),"\n",(0,t.jsx)(n.li,{children:"abstract value bottom at all other program points."}),"\n",(0,t.jsx)(n.li,{children:"Implying nothing is visited except entry point, and that variables uninitialized at entry -> take arbitrary values."}),"\n",(0,t.jsx)(n.li,{children:"Program point can be before, after or during for the node."}),"\n",(0,t.jsx)(n.li,{children:"Assume program point as the edge for now."}),"\n",(0,t.jsx)(n.li,{children:"Analysis updates the values at each program point."}),"\n",(0,t.jsx)(n.li,{children:"Update is done based on the predecessor of the program point."}),"\n",(0,t.jsxs)(n.li,{children:["E.g. after ",(0,t.jsx)(n.code,{children:"z = 3"}),", analysis updates z's abstract value to 3. True branch is always taken. False branch is infeasible -> program will never take that path. Should analysis interpret conditional? If not interpret conditional, assume false state is feasible.\nChecking value of ",(0,t.jsx)(n.code,{children:"x==1"}),". ",(0,t.jsx)(n.code,{children:"x!=1"})," cannot be represented by our domain. x is some value other than 1. represent as unknown in the false branch and 1 in the true branch.\n",(0,t.jsx)(n.code,{children:"y=7"}),", analysis knows ",(0,t.jsx)(n.code,{children:"y=7"}),". Analysis concludes ",(0,t.jsx)(n.code,{children:"x=1, y=7, z=3 "}),". For ",(0,t.jsx)(n.code,{children:"y = z + 4"}),",\nanalysis has seen ",(0,t.jsx)(n.code,{children:"z=3"})," befor this path, so\nit include ",(0,t.jsx)(n.code,{children:"y=7"}),", and concludes assertion is valid."]}),"\n",(0,t.jsx)(n.li,{children:"Iterative approximation -> analysis can visit same program point multiple times -> due to presence of loops -> to update facts."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Another Example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Iterative Approximation:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"abstract value top at the entry and bottom everywhere else."}),"\n",(0,t.jsx)(n.li,{children:"Program points: loop header, entry of loop body, exit of loop body."}),"\n",(0,t.jsx)(n.li,{children:"Take looping into consideration."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"b=1"})," at the entry, at the exit it's 2."]}),"\n",(0,t.jsx)(n.li,{children:"Analysis revisits loop again to show soundness."}),"\n",(0,t.jsx)(n.li,{children:"At the next entry, b can be 1 or 2, b updated to unknown."}),"\n",(0,t.jsx)(n.li,{children:"At the exit, updated to unknown as well."}),"\n",(0,t.jsx)(n.li,{children:"Analyse loop again, concludes b has saturated at entry and exit. Correct value of b is unknown."}),"\n",(0,t.jsx)(n.li,{children:"Combining multiple abstract state is called merging."}),"\n",(0,t.jsxs)(n.li,{children:["Combination operator -> form of conjuction ->\nfor ",(0,t.jsx)(n.code,{children:"b=1"}),", it must be ",(0,t.jsx)(n.code,{children:"=1"})," in all paths. When merge states from 1st and 2nd iteration, ",(0,t.jsx)(n.code,{children:"b"})," is unknown. If trying to prove, ",(0,t.jsx)(n.code,{children:"b"})," may be ",(0,t.jsx)(n.code,{children:"= 1"}),", define combination op\nas a disjunction. If ",(0,t.jsx)(n.code,{children:"b=1"})," on atleast 1 program path, it should ",(0,t.jsx)(n.code,{children:"=1"})," in abstract state."]}),"\n",(0,t.jsx)(n.li,{children:"This choice made by analysis designer based on consumer and tradeoffs."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"recap-parts-of-a-static-analysis",children:"Recap: Parts of a Static Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Specify program representation precisely: CFG, AST, bytecode."}),"\n",(0,t.jsx)(n.li,{children:"Specify abstract domain -> how to approximate program values."}),"\n",(0,t.jsx)(n.li,{children:"Specify transfer functions -> how to calculate abstract state given program statement -> also specific how to combine information at control point -> assignments, conditionals, merge points."}),"\n",(0,t.jsx)(n.li,{children:"Specify fixed-point computation algorithm -> invokes transfer functions of program statements -> fixed point means abstract states are no longer changing, so analysis should terminate."}),"\n",(0,t.jsx)(n.li,{children:"At each step, many choices -> choice dependent on the application and tradeoff -> there is no one-size-fits-all static analysis."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var t=s(6540);const a={},i=t.createContext(a);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);