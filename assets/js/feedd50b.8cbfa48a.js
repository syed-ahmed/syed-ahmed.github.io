"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9492],{2633:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var s=i(4848),l=i(8453);const r={},d="Chapter 1",t={id:"C++/professional_cpp/Part 1/crash_course",title:"Chapter 1",description:"C++ Crash Course",source:"@site/docs/C++/professional_cpp/Part 1/0_crash_course.md",sourceDirName:"C++/professional_cpp/Part 1",slug:"/C++/professional_cpp/Part 1/crash_course",permalink:"/docs/C++/professional_cpp/Part 1/crash_course",draft:!1,unlisted:!1,editUrl:"https://github.com/syed-ahmed/syed-ahmed.github.io/blob/main/website/docs/C++/professional_cpp/Part 1/0_crash_course.md?plain=1",tags:[],version:"current",sidebarPosition:0,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Notes",permalink:"/docs/intro"},next:{title:"Introduction to CUDA C++",permalink:"/docs/CUDA/cuda_training/intro"}},a={},c=[{value:"C++ Crash Course",id:"c-crash-course",level:2},{value:"Hello World",id:"hello-world",level:3},{value:"Importing",id:"importing",level:4},{value:"Preprocessor Directives",id:"preprocessor-directives",level:4},{value:"Main function",id:"main-function",level:4},{value:"I/O Streams",id:"io-streams",level:4},{value:"Namespaces",id:"namespaces",level:3},{value:"Nested namespace",id:"nested-namespace",level:4},{value:"Namespace alias",id:"namespace-alias",level:4},{value:"Literals",id:"literals",level:3},{value:"Variables",id:"variables",level:3},{value:"Numerical Limits",id:"numerical-limits",level:4},{value:"Zero Initialization",id:"zero-initialization",level:4},{value:"Casting",id:"casting",level:4},{value:"Floating-Point Numbers",id:"floating-point-numbers",level:4},{value:"Operators",id:"operators",level:3},{value:"Enumerated Types",id:"enumerated-types",level:3},{value:"Old-style Enumerated Types",id:"old-style-enumerated-types",level:4},{value:"Structs",id:"structs",level:3},{value:"Conditional Statements",id:"conditional-statements",level:3},{value:"if/else Statements",id:"ifelse-statements",level:4},{value:"Initializers for if Statements",id:"initializers-for-if-statements",level:5},{value:"switch Statements",id:"switch-statements",level:4},{value:"The Conditional Operator",id:"the-conditional-operator",level:3},{value:"Logical Evaluation Operators",id:"logical-evaluation-operators",level:3},{value:"Three-Way Comparisons",id:"three-way-comparisons",level:3},{value:"Functions",id:"functions",level:3},{value:"Function Return Type Deduction",id:"function-return-type-deduction",level:4},{value:"Current Function\u2019s Name",id:"current-functions-name",level:4},{value:"Function Overloading",id:"function-overloading",level:4},{value:"Attributes",id:"attributes",level:3},{value:"<code>[[nodiscard]]</code>",id:"nodiscard",level:4},{value:"<code>[[maybe_unused]]</code>",id:"maybe_unused",level:4},{value:"<code>[[noreturn]]</code>",id:"noreturn",level:4},{value:"<code>[[deprecated]]</code>",id:"deprecated",level:4},{value:"<code>[[likely]]</code>",id:"likely",level:4},{value:"<code>[[unlikely]]</code>",id:"unlikely",level:4},{value:"C-Style Arrays",id:"c-style-arrays",level:3},{value:"<code>std::array</code>",id:"stdarray",level:3},{value:"<code>std::vector</code>",id:"stdvector",level:3},{value:"<code>std::pair</code>",id:"stdpair",level:3},{value:"<code>std::optional</code>",id:"stdoptional",level:3},{value:"Structured Bindings",id:"structured-bindings",level:3},{value:"Loops",id:"loops",level:3},{value:"The while Loop",id:"the-while-loop",level:4},{value:"The do/while Loop",id:"the-dowhile-loop",level:4},{value:"The for Loop",id:"the-for-loop",level:4},{value:"The Range-Based for Loop",id:"the-range-based-for-loop",level:4},{value:"Initializer Lists",id:"initializer-lists",level:3},{value:"Strings in C++",id:"strings-in-c",level:3},{value:"C++ as an Object-Oriented Language",id:"c-as-an-object-oriented-language",level:3},{value:"Defining Classes",id:"defining-classes",level:4},{value:"Using Classes",id:"using-classes",level:4},{value:"Scope Resolution",id:"scope-resolution",level:3},{value:"Uniform Initialization",id:"uniform-initialization",level:3},{value:"Designated Initializers",id:"designated-initializers",level:4},{value:"Pointers and Dynamic Memory",id:"pointers-and-dynamic-memory",level:3},{value:"The Stack and the Free Store",id:"the-stack-and-the-free-store",level:4},{value:"Working with Pointers",id:"working-with-pointers",level:4},{value:"Dynamically Allocated Arrays",id:"dynamically-allocated-arrays",level:4},{value:"Null Pointer Constant",id:"null-pointer-constant",level:4},{value:"The Use of const",id:"the-use-of-const",level:3},{value:"<code>const</code> as a Qualifier for a Type",id:"const-as-a-qualifier-for-a-type",level:4},{value:"<code>const</code> Methods",id:"const-methods",level:4},{value:"The <code>constexpr</code> Keyword",id:"the-constexpr-keyword",level:3},{value:"The <code>consteval</code> Keyword",id:"the-consteval-keyword",level:3},{value:"References",id:"references",level:3},{value:"Reference Variables",id:"reference-variables",level:4},{value:"Reference Data Members",id:"reference-data-members",level:4},{value:"Reference Parameters",id:"reference-parameters",level:4},{value:"Reference Return Values",id:"reference-return-values",level:4},{value:"Deciding Between References and Pointers",id:"deciding-between-references-and-pointers",level:4},{value:"<code>const_cast()</code>",id:"const_cast",level:3},{value:"Exceptions",id:"exceptions",level:3},{value:"Type Aliases",id:"type-aliases",level:3},{value:"<code>typedefs</code>",id:"typedefs",level:3},{value:"Type Inference",id:"type-inference",level:3},{value:"The <code>auto</code> Keyword",id:"the-auto-keyword",level:4},{value:"The <code>decltype</code> Keyword",id:"the-decltype-keyword",level:4},{value:"The Standard Library",id:"the-standard-library",level:3},{value:"Your First Bigger C++ Program",id:"your-first-bigger-c-program",level:2},{value:"An Employee Records System",id:"an-employee-records-system",level:3},{value:"The Employee Class",id:"the-employee-class",level:3},{value:"<code>Employee.cppm</code>",id:"employeecppm",level:4},{value:"<code>Employee.cpp</code>",id:"employeecpp",level:4},{value:"<code>EmployeeTest.cpp</code>",id:"employeetestcpp",level:4},{value:"The Database Class",id:"the-database-class",level:3},{value:"<code>Database.cppm</code>",id:"databasecppm",level:4},{value:"<code>Database.cpp</code>",id:"databasecpp",level:4},{value:"<code>DatabaseTest.cpp</code>",id:"databasetestcpp",level:4},{value:"The User Interface",id:"the-user-interface",level:3},{value:"Evaluating the Program",id:"evaluating-the-program",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"chapter-1",children:"Chapter 1"}),"\n",(0,s.jsx)(n.h2,{id:"c-crash-course",children:"C++ Crash Course"}),"\n",(0,s.jsx)(n.h3,{id:"hello-world",children:"Hello World"}),"\n",(0,s.jsx)(n.h4,{id:"importing",children:"Importing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#include"})," replaced by ",(0,s.jsx)(n.code,{children:"import"})," in C++20. New concept called modules.\ne.g. ",(0,s.jsx)(n.code,{children:"import <iostream>"})," instead of ",(0,s.jsx)(n.code,{children:"#include <iostream>"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"preprocessor-directives",children:"Preprocessor Directives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Directives starting with ",(0,s.jsx)(n.code,{children:"#"})," uses the preprocessor."]}),"\n",(0,s.jsx)(n.li,{children:"Function declaration: signature  for the function, inputs, output, types."}),"\n",(0,s.jsx)(n.li,{children:"Function definition: actual code of the function."}),"\n",(0,s.jsx)(n.li,{children:"With C++20 modules, no need to separate declaration from definition.\nCan do it if wanted to."}),"\n",(0,s.jsxs)(n.li,{children:["Old C standard library do not use namespace. Standard C library\nprefixed with ",(0,s.jsx)(n.code,{children:"c"})," use the ",(0,s.jsx)(n.code,{children:"std"})," namespace. C standard library\nare not guaranteed to be importable with ",(0,s.jsx)(n.code,{children:"import"})," in C++20."]}),"\n",(0,s.jsxs)(n.li,{children:["Common preprocessor directive:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#include"}),": header files."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#define"}),": macro."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#ifdef...#endif"}),"/",(0,s.jsx)(n.code,{children:"#ifndef...#endif"}),": prevents circular includes\nExample:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#ifndef TEST_FILE_H\n#define TEST_FILE_H\n// ...\n#endif\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"#pragma"}),": compiler specific directive. Can replace the above with\n",(0,s.jsx)(n.code,{children:"#pragma once"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"main-function",children:"Main function"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"main()"}),": start of the program.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Return type is ",(0,s.jsx)(n.code,{children:"int"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"zero returned automatically if not explicit."}),"\n",(0,s.jsxs)(n.li,{children:["can take no params or two params: ",(0,s.jsx)(n.code,{children:"int argc, char* argv[]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"argc"}),": number of args passed to program."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"argv"}),": actual args starting at index 1. Index 0 can be the program\nname."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"io-streams",children:"I/O Streams"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::cout"}),": outputs to user console."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::cerr"}),": outputs to error console."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<<"}),": outputs down the stream."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::endl"}),": end of line sequence. Output everything and move to next\nline. Alternatively use ",(0,s.jsx)(n.code,{children:"\\n"})," escape sequence, i.e. a new line char."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"std::format"})," with C++20, from ",(0,s.jsx)(n.code,{children:"<format>"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Common escape sequences to be used with quotes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\\n"}),": new line, moves cursor to beginning of next line and advance."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\\r"}),": carriage return, moves cursor to beginning of next line\nbut doesn't advance."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\\t"}),": tab."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\\\\"}),": backslash."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'\\"'}),": quotation."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::endl"})," flushes the buffer, so it will have a performance impact.\n",(0,s.jsx)(n.code,{children:"\\n"})," doesn't flush the buffer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::cin"}),": accept input from user with the ",(0,s.jsx)(n.code,{children:">>"})," operator."]}),"\n",(0,s.jsxs)(n.li,{children:["Use iostream and format instead of ",(0,s.jsx)(n.code,{children:"printf"})," and ",(0,s.jsx)(n.code,{children:"scanf"}),", since they\nprovide type safety."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"namespaces",children:"Namespaces"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["avoids naming conflict, defines a context for the names.\nExample:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'namespace my_lib {\n  void foo() {\n    std::cout << "Hi!" << std::endl;\n  }\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Call using scope resolution operator",(0,s.jsx)(n.code,{children:"::"}),". Example: ",(0,s.jsx)(n.code,{children:"my_lib::foo();"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Code in the same namespace can call each other without usiing scope\nresolution. Makes code readable."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"using"})," directive: signals the compiler that subsequent code is from\nthe specified namespace."]}),"\n",(0,s.jsxs)(n.li,{children:["Don't overuse ",(0,s.jsx)(n.code,{children:"using"}),", will create name conflicts."]}),"\n",(0,s.jsxs)(n.li,{children:["Can use ",(0,s.jsx)(n.code,{children:"using"})," for a particular item. Example: ",(0,s.jsx)(n.code,{children:"using std::cout"}),"\nand then just referring ",(0,s.jsx)(n.code,{children:"cout"}),". That way everything else still\nneeds to use ",(0,s.jsx)(n.code,{children:"std::"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Never put ",(0,s.jsx)(n.code,{children:"using"})," in a header file or global scope. Use it in\nnamespace or class scope. OK to use ",(0,s.jsx)(n.code,{children:"using"})," in a module interface\nfile as long as not exporting."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"nested-namespace",children:"Nested namespace"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["namespace inside another one.\nExample:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// before c++17\nnamespace foo {\n  namespace bar {\n\n  }\n}\n// after c++17\nnamespace foo::bar {\n\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"namespace-alias",children:"Namespace alias"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"give new/shorter name to a namespace.\nExample: `namespace baz = foo::bar;"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"literals",children:"Literals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Literals: used to write numbers or strings.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"decimal, 123"}),"\n",(0,s.jsx)(n.li,{children:"octal, 0173"}),"\n",(0,s.jsx)(n.li,{children:"hex, 0x7B"}),"\n",(0,s.jsx)(n.li,{children:"binary, 0b1111011"}),"\n",(0,s.jsx)(n.li,{children:"float, 3.14f"}),"\n",(0,s.jsx)(n.li,{children:"double, 3.14"}),"\n",(0,s.jsx)(n.li,{children:"hex float, 0x3.ABCp-10"}),"\n",(0,s.jsx)(n.li,{children:"single char, 'a'"}),"\n",(0,s.jsx)(n.li,{children:"zero terminated char array"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Can define custom literal."}),"\n",(0,s.jsx)(n.li,{children:"Digit separator can be used in numeric literals, i.e. single\nquote char. Example: 23'456'789."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"variables",children:"Variables"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Uninitialized variables: potential source of bugs."}),"\n",(0,s.jsxs)(n.li,{children:["Uniform initialization syntax:\nExample:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int my_int = 8;\n// vs from C++11\nint my_int {8};\n"})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Use uniform initialization."}),"\n",(0,s.jsx)(n.li,{children:"Variables are strongly typed."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"char"})," is different than ",(0,s.jsx)(n.code,{children:"signed char"})," or ",(0,s.jsx)(n.code,{children:"unsigned char"}),". Only use ",(0,s.jsx)(n.code,{children:"char"})," to represent characters."]}),"\n",(0,s.jsxs)(n.li,{children:["From C++17 ",(0,s.jsx)(n.code,{children:"std::byte"})," in ",(0,s.jsx)(n.code,{children:"<cstddef>"}),". Before ",(0,s.jsx)(n.code,{children:"char"})," or ",(0,s.jsx)(n.code,{children:"unsigned char"})," used for byte."]}),"\n",(0,s.jsxs)(n.li,{children:["No string type in C++. STL has ",(0,s.jsx)(n.code,{children:"std::string"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"numerical-limits",children:"Numerical Limits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"std::numeric_limits"})," from ",(0,s.jsx)(n.code,{children:"<limits>"})," instead of C ",(0,s.jsx)(n.code,{children:"#defines"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::numeric_limits<int>::min() == std::numeric_limits<int>::lowest()"}),", but\n",(0,s.jsx)(n.code,{children:"std::numeric_limits<double>::min() != std::numeric_limits<double>::lowest()"}),","]}),"\n",(0,s.jsx)(n.li,{children:"Minimum for float is the smallest possible value. Lowest for float is the most negative value representable."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"zero-initialization",children:"Zero Initialization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Empty curly brackets ",(0,s.jsx)(n.code,{children:"{}"})]}),"\n",(0,s.jsxs)(n.li,{children:["Initialzes primitive types to 0, pointer to ",(0,s.jsx)(n.code,{children:"nullptr"})]}),"\n",(0,s.jsx)(n.li,{children:"Calls default constructor for objects."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"casting",children:"Casting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"static_cast<>"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Variables can be auto casted, e.g. short to long."}),"\n",(0,s.jsx)(n.li,{children:"Can lose data with casting."}),"\n",(0,s.jsx)(n.li,{children:"OK to cast if types are compatible."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"floating-point-numbers",children:"Floating-Point Numbers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"FP math with order of magnitude differences can error."}),"\n",(0,s.jsx)(n.li,{children:"Difference between two close FP can lose precision."}),"\n",(0,s.jsx)(n.li,{children:"Many decimals can't be represented."}),"\n",(0,s.jsxs)(n.li,{children:["Special floats:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"+/- infinity: e.g. 1/0."}),"\n",(0,s.jsx)(n.li,{children:"NaN: not a number, e.g 0/0."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"std::isnan()"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"operators",children:"Operators"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Binary operator: operates on two expressions."}),"\n",(0,s.jsx)(n.li,{children:"Unary operator: operates on single expression."}),"\n",(0,s.jsx)(n.li,{children:"Ternary operator: operates on three expressions."}),"\n",(0,s.jsxs)(n.li,{children:["What is the output of this program?","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int someInteger { 256 };\nshort someShort;\nlong someLong;\nfloat someFloat;\ndouble someDouble;\nsomeInteger++;\nsomeInteger *= 2;\nsomeShort = static_cast<short>(someInteger);\nsomeLong = someShort * 10000;\nsomeFloat = someLong + 0.785f;\nsomeDouble = static_cast<double>(someFloat) / 100000;\ncout << someDouble << endl;\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Output:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"increment by 1 -> 257."}),"\n",(0,s.jsx)(n.li,{children:"times 2 -> 514."}),"\n",(0,s.jsx)(n.li,{children:"static cast to short -> short is 2 bytes, so can hold 514."}),"\n",(0,s.jsx)(n.li,{children:"times 10,000 -> 5,140,000 -> implicit cast to long -> long is 4 bytes -> in range, so can hold."}),"\n",(0,s.jsx)(n.li,{children:"float in range, long gets implicit casted to float -> big float added with small float -> loss of precision -> 5,140,001.0"}),"\n",(0,s.jsxs)(n.li,{children:["Cast to double and divide -> 51.40001 (with ",(0,s.jsx)(n.code,{children:"cout.precision(7);"}),")"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Order of execution: /,*,% first from left to right, then +,- and the bitwise."}),"\n",(0,s.jsx)(n.li,{children:"Make order explicit with paranthesis."}),"\n",(0,s.jsx)(n.li,{children:"Evaluation order decided by precedence."}),"\n",(0,s.jsx)(n.li,{children:"Ops with higher precedance evaluated before lower ones."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"enumerated-types",children:"Enumerated Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Defines a sequence, can declare variables with that sequence."}),"\n",(0,s.jsxs)(n.li,{children:["Strongly typed enumeration types: ",(0,s.jsx)(n.code,{children:"enum class MyEnum {Foo, Bar, Baz};"})]}),"\n",(0,s.jsx)(n.li,{children:"Tightly defines the range of values for a variable."}),"\n",(0,s.jsx)(n.li,{children:"Enums are just integers."}),"\n",(0,s.jsxs)(n.li,{children:["If integers are not specified, compiler assigns automatically.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Starts with 0."}),"\n",(0,s.jsx)(n.li,{children:"Can define some and leave some out."}),"\n",(0,s.jsx)(n.li,{children:"Undefined types are assigned a value of the previous enum member incremented by 1."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Cannot automatically convert to integers."}),"\n",(0,s.jsxs)(n.li,{children:["By default, enum value is an integer. Can change it, e.g. ",(0,s.jsx)(n.code,{children:"enum class MyEnum: unsigned long {...}"})]}),"\n",(0,s.jsx)(n.li,{children:"Enum values not automatically exported to enclosing scope, useful for giving short names to enum values."}),"\n",(0,s.jsxs)(n.li,{children:["Have to fully qualify enum values or use a ",(0,s.jsx)(n.code,{children:"using enum"})," or ",(0,s.jsx)(n.code,{children:"using"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["C++20, can use ",(0,s.jsx)(n.code,{children:"using enum MyEnum"}),". Minimize the scope when using this, so that name clashes are avoided."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"old-style-enumerated-types",children:"Old-style Enumerated Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enum"})," instead of ",(0,s.jsx)(n.code,{children:"enum class"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Use strongly typed enum instead of old style."}),"\n",(0,s.jsx)(n.li,{children:"Values exported to enclosing scope, so can use\nin the parent scope without fully qualifying,\ncan result in name clashes. Need to make enum values unique to avoid this."}),"\n",(0,s.jsx)(n.li,{children:"Not strongly typed, so not type safe."}),"\n",(0,s.jsx)(n.li,{children:"Interpreted as ints, so can compare different enums or pass wrong enum types."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"structs",children:"Structs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Encapsulate one or more types"}),"\n",(0,s.jsxs)(n.li,{children:["Module interface file (.cppm)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"First line is module declaration, states that file is defining a module."}),"\n",(0,s.jsx)(n.li,{children:"explicitly export."}),"\n",(0,s.jsxs)(n.li,{children:["Example:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"export module employee;\nexport struct Employee {\n  ...\n};\n"})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Angle brackets must not be used when importing modules."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"conditional-statements",children:"Conditional Statements"}),"\n",(0,s.jsx)(n.p,{children:"Two types on conditional statements in C++."}),"\n",(0,s.jsx)(n.h4,{id:"ifelse-statements",children:"if/else Statements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Expression inside parenthesis must be a boolean."}),"\n",(0,s.jsxs)(n.li,{children:["Value of 0 evaluates to ",(0,s.jsx)(n.code,{children:"false"}),", non-zero is ",(0,s.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"if (<condition 1>) {\n  \n} else if (<condition 2>) {\n\n} else {\n\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"initializers-for-if-statements",children:"Initializers for if Statements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Can include initializer inside an if statement."}),"\n",(0,s.jsxs)(n.li,{children:["Syntax:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"if (<initializer>; <conditional>) {\n  ...\n} else if (...) {\n  ...\n} else {\n  ...\n}\n"})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Variable in the initializer available to all the other parts of the if statement  (also other places in a cascaded if statements). Initializer variables not available anywhere else."}),"\n",(0,s.jsxs)(n.li,{children:["Example:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"if (Employee employee { getEmployee() }; employee.salary > 1000) { ... }\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"switch-statements",children:"switch Statements"}),"\n",(0,s.jsx)(n.h3,{id:"the-conditional-operator",children:"The Conditional Operator"}),"\n",(0,s.jsx)(n.h3,{id:"logical-evaluation-operators",children:"Logical Evaluation Operators"}),"\n",(0,s.jsx)(n.h3,{id:"three-way-comparisons",children:"Three-Way Comparisons"}),"\n",(0,s.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.h4,{id:"function-return-type-deduction",children:"Function Return Type Deduction"}),"\n",(0,s.jsx)(n.h4,{id:"current-functions-name",children:"Current Function\u2019s Name"}),"\n",(0,s.jsx)(n.h4,{id:"function-overloading",children:"Function Overloading"}),"\n",(0,s.jsx)(n.h3,{id:"attributes",children:"Attributes"}),"\n",(0,s.jsx)(n.h4,{id:"nodiscard",children:(0,s.jsx)(n.code,{children:"[[nodiscard]]"})}),"\n",(0,s.jsx)(n.h4,{id:"maybe_unused",children:(0,s.jsx)(n.code,{children:"[[maybe_unused]]"})}),"\n",(0,s.jsx)(n.h4,{id:"noreturn",children:(0,s.jsx)(n.code,{children:"[[noreturn]]"})}),"\n",(0,s.jsx)(n.h4,{id:"deprecated",children:(0,s.jsx)(n.code,{children:"[[deprecated]]"})}),"\n",(0,s.jsx)(n.h4,{id:"likely",children:(0,s.jsx)(n.code,{children:"[[likely]]"})}),"\n",(0,s.jsx)(n.h4,{id:"unlikely",children:(0,s.jsx)(n.code,{children:"[[unlikely]]"})}),"\n",(0,s.jsx)(n.h3,{id:"c-style-arrays",children:"C-Style Arrays"}),"\n",(0,s.jsx)(n.h3,{id:"stdarray",children:(0,s.jsx)(n.code,{children:"std::array"})}),"\n",(0,s.jsx)(n.h3,{id:"stdvector",children:(0,s.jsx)(n.code,{children:"std::vector"})}),"\n",(0,s.jsx)(n.h3,{id:"stdpair",children:(0,s.jsx)(n.code,{children:"std::pair"})}),"\n",(0,s.jsx)(n.h3,{id:"stdoptional",children:(0,s.jsx)(n.code,{children:"std::optional"})}),"\n",(0,s.jsx)(n.h3,{id:"structured-bindings",children:"Structured Bindings"}),"\n",(0,s.jsx)(n.h3,{id:"loops",children:"Loops"}),"\n",(0,s.jsx)(n.h4,{id:"the-while-loop",children:"The while Loop"}),"\n",(0,s.jsx)(n.h4,{id:"the-dowhile-loop",children:"The do/while Loop"}),"\n",(0,s.jsx)(n.h4,{id:"the-for-loop",children:"The for Loop"}),"\n",(0,s.jsx)(n.h4,{id:"the-range-based-for-loop",children:"The Range-Based for Loop"}),"\n",(0,s.jsx)(n.h3,{id:"initializer-lists",children:"Initializer Lists"}),"\n",(0,s.jsx)(n.h3,{id:"strings-in-c",children:"Strings in C++"}),"\n",(0,s.jsx)(n.h3,{id:"c-as-an-object-oriented-language",children:"C++ as an Object-Oriented Language"}),"\n",(0,s.jsx)(n.h4,{id:"defining-classes",children:"Defining Classes"}),"\n",(0,s.jsx)(n.h4,{id:"using-classes",children:"Using Classes"}),"\n",(0,s.jsx)(n.h3,{id:"scope-resolution",children:"Scope Resolution"}),"\n",(0,s.jsx)(n.h3,{id:"uniform-initialization",children:"Uniform Initialization"}),"\n",(0,s.jsx)(n.h4,{id:"designated-initializers",children:"Designated Initializers"}),"\n",(0,s.jsx)(n.h3,{id:"pointers-and-dynamic-memory",children:"Pointers and Dynamic Memory"}),"\n",(0,s.jsx)(n.h4,{id:"the-stack-and-the-free-store",children:"The Stack and the Free Store"}),"\n",(0,s.jsx)(n.h4,{id:"working-with-pointers",children:"Working with Pointers"}),"\n",(0,s.jsx)(n.h4,{id:"dynamically-allocated-arrays",children:"Dynamically Allocated Arrays"}),"\n",(0,s.jsx)(n.h4,{id:"null-pointer-constant",children:"Null Pointer Constant"}),"\n",(0,s.jsx)(n.h3,{id:"the-use-of-const",children:"The Use of const"}),"\n",(0,s.jsxs)(n.h4,{id:"const-as-a-qualifier-for-a-type",children:[(0,s.jsx)(n.code,{children:"const"})," as a Qualifier for a Type"]}),"\n",(0,s.jsxs)(n.h4,{id:"const-methods",children:[(0,s.jsx)(n.code,{children:"const"})," Methods"]}),"\n",(0,s.jsxs)(n.h3,{id:"the-constexpr-keyword",children:["The ",(0,s.jsx)(n.code,{children:"constexpr"})," Keyword"]}),"\n",(0,s.jsxs)(n.h3,{id:"the-consteval-keyword",children:["The ",(0,s.jsx)(n.code,{children:"consteval"})," Keyword"]}),"\n",(0,s.jsx)(n.h3,{id:"references",children:"References"}),"\n",(0,s.jsx)(n.h4,{id:"reference-variables",children:"Reference Variables"}),"\n",(0,s.jsx)(n.h4,{id:"reference-data-members",children:"Reference Data Members"}),"\n",(0,s.jsx)(n.h4,{id:"reference-parameters",children:"Reference Parameters"}),"\n",(0,s.jsx)(n.h4,{id:"reference-return-values",children:"Reference Return Values"}),"\n",(0,s.jsx)(n.h4,{id:"deciding-between-references-and-pointers",children:"Deciding Between References and Pointers"}),"\n",(0,s.jsx)(n.h3,{id:"const_cast",children:(0,s.jsx)(n.code,{children:"const_cast()"})}),"\n",(0,s.jsx)(n.h3,{id:"exceptions",children:"Exceptions"}),"\n",(0,s.jsx)(n.h3,{id:"type-aliases",children:"Type Aliases"}),"\n",(0,s.jsx)(n.h3,{id:"typedefs",children:(0,s.jsx)(n.code,{children:"typedefs"})}),"\n",(0,s.jsx)(n.h3,{id:"type-inference",children:"Type Inference"}),"\n",(0,s.jsxs)(n.h4,{id:"the-auto-keyword",children:["The ",(0,s.jsx)(n.code,{children:"auto"})," Keyword"]}),"\n",(0,s.jsxs)(n.h4,{id:"the-decltype-keyword",children:["The ",(0,s.jsx)(n.code,{children:"decltype"})," Keyword"]}),"\n",(0,s.jsx)(n.h3,{id:"the-standard-library",children:"The Standard Library"}),"\n",(0,s.jsx)(n.h2,{id:"your-first-bigger-c-program",children:"Your First Bigger C++ Program"}),"\n",(0,s.jsx)(n.h3,{id:"an-employee-records-system",children:"An Employee Records System"}),"\n",(0,s.jsx)(n.h3,{id:"the-employee-class",children:"The Employee Class"}),"\n",(0,s.jsx)(n.h4,{id:"employeecppm",children:(0,s.jsx)(n.code,{children:"Employee.cppm"})}),"\n",(0,s.jsx)(n.h4,{id:"employeecpp",children:(0,s.jsx)(n.code,{children:"Employee.cpp"})}),"\n",(0,s.jsx)(n.h4,{id:"employeetestcpp",children:(0,s.jsx)(n.code,{children:"EmployeeTest.cpp"})}),"\n",(0,s.jsx)(n.h3,{id:"the-database-class",children:"The Database Class"}),"\n",(0,s.jsx)(n.h4,{id:"databasecppm",children:(0,s.jsx)(n.code,{children:"Database.cppm"})}),"\n",(0,s.jsx)(n.h4,{id:"databasecpp",children:(0,s.jsx)(n.code,{children:"Database.cpp"})}),"\n",(0,s.jsx)(n.h4,{id:"databasetestcpp",children:(0,s.jsx)(n.code,{children:"DatabaseTest.cpp"})}),"\n",(0,s.jsx)(n.h3,{id:"the-user-interface",children:"The User Interface"}),"\n",(0,s.jsx)(n.h3,{id:"evaluating-the-program",children:"Evaluating the Program"}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>t});var s=i(6540);const l={},r=s.createContext(l);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);